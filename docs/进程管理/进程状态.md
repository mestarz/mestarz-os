```c
volatile long state;	/* -1 unrunnable, 0 runnable, >0 stopped */

...
  
/* task state */
	int exit_state;
	int exit_code, exit_signal;
	int pdeath_signal;  /*  The signal sent when the parent dies  */
	/* ??? */
	unsigned int personality;
	unsigned did_exec:1;
	unsigned in_execve:1;	/* Tell the LSMs that the process is doing an
				 * execve */
	unsigned in_iowait:1;


	/* Revert to default priority/policy when forking */
	unsigned sched_reset_on_fork:1;
```

当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。

通过set_task_state(task, state)设置进程的状态; 代码位置 `./include/linux/sched.h` 

```
#define __set_task_state(tsk, state_value)      \
    do { (tsk)->state = (state_value); } while (0)
#define set_task_state(tsk, state_value)        \
    set_mb((tsk)->state, (state_value))
```

ps:其中do{}while(0)语句是为了防止宏失效 例如：

```
#define Hong(p) A(p); B(p);

if(p!=NULL)
    Hong(p)
else
    ...
    
#宏展开后else失效
if(p!=NULL)
    A(p);
    B(p);
else
    ...
#define Hong(p) {A(p); B(p);}

if(p!=NULL)
    Hong(p);
else
    ...
    
#宏展开后else失效
if(p!=NULL)
{
    A(p); 
    B(p);
};
else
    ...
```

很明显，current指向的是当前进程的进程描述符

```
#define __set_current_state(state_value)            \
    do { current->state = (state_value); } while (0)
#define set_current_state(state_value)      \
    set_mb(current->state, (state_value))
```



当一个程序调用执行了系统调用或者触发了某个异常，它就陷入了内核空间。此时，我们称内核“代表进程执行”并处于进程上下文中。在此上下文中current宏是有效的（current指向当前进程的进程描述符）。除非在此间隙有更高优先级的进程需要执行并由调度器做出了相应调整，否则在内核推出的时候，程序恢复在用户空间中继续执行。